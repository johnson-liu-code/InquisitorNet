# InquisitorNet - Warhammer 40K Inquisitor Bot Network
# Starter Codebase - Phase 1 Implementation
# -- Generated by Claude Sonnet 4 ... thanks Claude!
import os
import praw
import openai
import json
import sqlite3
import base64
import random
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from apscheduler.schedulers.background import BackgroundScheduler
import threading

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('inquisitor_net.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Configuration
class Config:
    """Configuration class for InquisitorNet"""
    
    # Reddit API Configuration
    REDDIT_CLIENT_ID = os.getenv('REDDIT_CLIENT_ID')
    REDDIT_CLIENT_SECRET = os.getenv('REDDIT_CLIENT_SECRET')
    REDDIT_USER_AGENT = os.getenv('REDDIT_USER_AGENT', 'InquisitorNet v1.0')
    
    # OpenAI Configuration
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
    OPENAI_MODEL = os.getenv('OPENAI_MODEL', 'gpt-3.5-turbo')
    
    # Bot Configuration
    SUBREDDIT_NAME = os.getenv('SUBREDDIT_NAME', 'OrdoImperialis')
    POST_COOLDOWN = int(os.getenv('POST_COOLDOWN', '3600'))  # 1 hour in seconds
    MAX_DAILY_POSTS = int(os.getenv('MAX_DAILY_POSTS', '5'))
    
    # Database
    DATABASE_PATH = os.getenv('DATABASE_PATH', 'inquisitor_net.db')

@dataclass
class InquisitorPersonality:
    """Defines an Inquisitor's personality and behavior"""
    name: str
    ordo: str
    philosophy: str  # 'puritan' or 'radical'
    traits: List[str]
    speech_patterns: List[str]
    encryption_key: str
    faction_relationships: Dict[str, str]  # faction -> relationship type

@dataclass
class BotMemory:
    """Stores bot's memory of conversations and actions"""
    post_id: str
    content: str
    timestamp: str
    author: str
    context: str
    response_generated: bool = False

class DatabaseManager:
    """Handles all database operations"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize database with required tables"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Bot activity tracking
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS bot_activity (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bot_name TEXT NOT NULL,
                action_type TEXT NOT NULL,
                post_id TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                content TEXT
            )
        ''')
        
        # Memory storage
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS bot_memory (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bot_name TEXT NOT NULL,
                post_id TEXT NOT NULL,
                content TEXT NOT NULL,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                context TEXT,
                response_generated BOOLEAN DEFAULT FALSE
            )
        ''')
        
        # Heresy investigations (for Phase 2)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS investigations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target_post_id TEXT NOT NULL,
                heresy_type TEXT NOT NULL,
                evidence TEXT NOT NULL,
                status TEXT DEFAULT 'open',
                assigned_inquisitor TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def log_activity(self, bot_name: str, action_type: str, post_id: str = None, content: str = None):
        """Log bot activity"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO bot_activity (bot_name, action_type, post_id, content)
            VALUES (?, ?, ?, ?)
        ''', (bot_name, action_type, post_id, content))
        conn.commit()
        conn.close()
    
    def store_memory(self, bot_name: str, memory: BotMemory):
        """Store bot memory"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO bot_memory (bot_name, post_id, content, context)
            VALUES (?, ?, ?, ?)
        ''', (bot_name, memory.post_id, memory.content, memory.context))
        conn.commit()
        conn.close()
    
    def get_recent_memories(self, bot_name: str, limit: int = 10) -> List[BotMemory]:
        """Retrieve recent memories for a bot"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            SELECT post_id, content, timestamp, context
            FROM bot_memory
            WHERE bot_name = ?
            ORDER BY timestamp DESC
            LIMIT ?
        ''', (bot_name, limit))
        
        memories = []
        for row in cursor.fetchall():
            memories.append(BotMemory(
                post_id=row[0],
                content=row[1],
                timestamp=row[2],
                author=bot_name,
                context=row[3]
            ))
        
        conn.close()
        return memories

class EncryptionModule:
    """Handles encryption/decryption of sensitive messages"""
    
    @staticmethod
    def caesar_cipher(text: str, shift: int) -> str:
        """Simple Caesar cipher encryption"""
        result = ""
        for char in text:
            if char.isalpha():
                ascii_offset = ord('A') if char.isupper() else ord('a')
                result += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
            else:
                result += char
        return result
    
    @staticmethod
    def base64_encode(text: str) -> str:
        """Base64 encoding"""
        return base64.b64encode(text.encode()).decode()
    
    @staticmethod
    def base64_decode(text: str) -> str:
        """Base64 decoding"""
        try:
            return base64.b64decode(text.encode()).decode()
        except:
            return text
    
    @staticmethod
    def encrypt_message(text: str, method: str = "caesar", key: int = 3) -> str:
        """Encrypt message using specified method"""
        if method == "caesar":
            return f"[ENCRYPTED-CAESAR]: {EncryptionModule.caesar_cipher(text, key)}"
        elif method == "base64":
            return f"[ENCRYPTED-BASE64]: {EncryptionModule.base64_encode(text)}"
        return text

class InquisitorBot:
    """Individual Inquisitor bot with personality and behavior"""
    
    def __init__(self, personality: InquisitorPersonality, reddit_credentials: Dict, 
                 openai_client, db_manager: DatabaseManager):
        self.personality = personality
        self.reddit = self._init_reddit(reddit_credentials)
        self.openai_client = openai_client
        self.db_manager = db_manager
        self.last_post_time = datetime.now() - timedelta(hours=2)
        self.daily_post_count = 0
        self.daily_reset_time = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        logger.info(f"Initialized Inquisitor {self.personality.name} of {self.personality.ordo}")
    
    def _init_reddit(self, credentials: Dict) -> praw.Reddit:
        """Initialize Reddit API connection"""
        return praw.Reddit(
            client_id=credentials['client_id'],
            client_secret=credentials['client_secret'],
            username=credentials['username'],
            password=credentials['password'],
            user_agent=Config.REDDIT_USER_AGENT
        )
    
    def _reset_daily_counter(self):
        """Reset daily post counter if needed"""
        now = datetime.now()
        if now >= self.daily_reset_time + timedelta(days=1):
            self.daily_post_count = 0
            self.daily_reset_time = now.replace(hour=0, minute=0, second=0, microsecond=0)
    
    def can_post(self) -> bool:
        """Check if bot can post based on rate limits"""
        self._reset_daily_counter()
        
        time_since_last_post = datetime.now() - self.last_post_time
        cooldown_met = time_since_last_post.total_seconds() >= Config.POST_COOLDOWN
        daily_limit_ok = self.daily_post_count < Config.MAX_DAILY_POSTS
        
        return cooldown_met and daily_limit_ok
    
    def generate_prompt(self, context: str, action_type: str) -> str:
        """Generate personality-appropriate prompt for OpenAI"""
        personality_desc = (
            f"You are {self.personality.name}, an Inquisitor of the {self.personality.ordo}."
            f"You are a {self.personality.philosophy} who believes in the absolute authority of the God-Emperor."
            f"Personality traits: {', '.join(self.personality.traits)}"
            f"Speech patterns: {', '.join(self.personality.speech_patterns)}"
            f"Your responses should be:"
            f"- Formal and archaic in tone"
            f"- Filled with Warhammer 40K terminology"
            f"- Consistent with your puritan/radical philosophy"
            f"- Suspicious of heresy and xenos influence"
            f"- Appropriately dramatic and grim"
            f"Context: {context}"
            f"Action: {action_type}"
            f"Generate a response that is 2-3 paragraphs long and maintains character throughout."
        )

        return personality_desc
    
    def generate_response(self, prompt: str) -> str:
        """Generate response using OpenAI API"""
        try:
            response = self.openai_client.chat.completions.create(
                model=Config.OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a Warhammer 40K Inquisitor. Stay in character."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=500,
                temperature=0.8
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"OpenAI API error: {e}")
            return self._generate_fallback_response()
    
    def _generate_fallback_response(self) -> str:
        """Generate fallback response if OpenAI fails"""
        fallback_responses = [
            "By the Emperor's grace, I shall investigate this matter thoroughly.",
            "Heresy must be purged wherever it is found. The Emperor protects.",
            "The xenos threat is ever-present. We must remain vigilant.",
            "In the name of the Golden Throne, justice will be served."
        ]
        return random.choice(fallback_responses)
    
    def should_encrypt_message(self, content: str) -> bool:
        """Determine if message should be encrypted based on content"""
        sensitive_keywords = [
            'daemon', 'chaos', 'warp', 'exterminatus', 'classified',
            'heretical', 'forbidden', 'purge', 'elimination'
        ]
        return any(keyword in content.lower() for keyword in sensitive_keywords)
    
    def create_post(self, subreddit_name: str, discussion_topic: str = None) -> Optional[str]:
        """Create a new post in the subreddit"""
        if not self.can_post():
            logger.info(f"{self.personality.name} cannot post due to rate limits")
            return None
        
        try:
            # Generate discussion topic if not provided
            if not discussion_topic:
                discussion_topic = self._generate_discussion_topic()
            
            # Generate post content
            prompt = self.generate_prompt(
                f"Create a post about: {discussion_topic}",
                "creating a new discussion thread"
            )
            
            content = self.generate_response(prompt)
            
            # Encrypt if necessary
            if self.should_encrypt_message(content):
                content = EncryptionModule.encrypt_message(content)
            
            # Post to Reddit
            subreddit = self.reddit.subreddit(subreddit_name)
            submission = subreddit.submit(
                title=f"[{self.personality.ordo}] {discussion_topic}",
                selftext=content
            )
            
            # Update tracking
            self.last_post_time = datetime.now()
            self.daily_post_count += 1
            
            # Log activity
            self.db_manager.log_activity(
                self.personality.name,
                "create_post",
                submission.id,
                content[:100]
            )
            
            # Store memory
            memory = BotMemory(
                post_id=submission.id,
                content=content,
                timestamp=datetime.now().isoformat(),
                author=self.personality.name,
                context=f"Created post about: {discussion_topic}"
            )
            self.db_manager.store_memory(self.personality.name, memory)
            
            logger.info(f"{self.personality.name} created post: {submission.id}")
            return submission.id
            
        except Exception as e:
            logger.error(f"Error creating post for {self.personality.name}: {e}")
            return None
    
    def reply_to_post(self, post_id: str, subreddit_name: str) -> Optional[str]:
        """Reply to an existing post"""
        if not self.can_post():
            return None
        
        try:
            submission = self.reddit.submission(id=post_id)
            
            # Get context from original post
            context = f"Original post by {submission.author}: {submission.selftext[:200]}..."
            
            # Generate reply
            prompt = self.generate_prompt(
                context,
                "replying to a fellow Inquisitor's post"
            )
            
            reply_content = self.generate_response(prompt)
            
            # Encrypt if necessary
            if self.should_encrypt_message(reply_content):
                reply_content = EncryptionModule.encrypt_message(reply_content)
            
            # Post reply
            comment = submission.reply(reply_content)
            
            # Update tracking
            self.last_post_time = datetime.now()
            self.daily_post_count += 1
            
            # Log activity
            self.db_manager.log_activity(
                self.personality.name,
                "reply_to_post",
                comment.id,
                reply_content[:100]
            )
            
            # Store memory
            memory = BotMemory(
                post_id=comment.id,
                content=reply_content,
                timestamp=datetime.now().isoformat(),
                author=self.personality.name,
                context=f"Reply to post {post_id}"
            )
            self.db_manager.store_memory(self.personality.name, memory)
            
            logger.info(f"{self.personality.name} replied to post: {post_id}")
            return comment.id
            
        except Exception as e:
            logger.error(f"Error replying to post for {self.personality.name}: {e}")
            return None
    
    def _generate_discussion_topic(self) -> str:
        """Generate a discussion topic appropriate for the Inquisitor"""
        topics = {
            'Hereticus': [
                "Suspected Heretical Activities in Sector 7",
                "The Growing Threat of Mutant Cults",
                "Purging the Unclean: A Tactical Assessment",
                "Signs of Chaos Corruption Among the Masses"
            ],
            'Xenos': [
                "Alien Infiltration Patterns Detected",
                "Xenotech Contamination Reports",
                "Eldar Movements in the Outer Rim",
                "Tau Expansion Threatens Imperial Worlds"
            ],
            'Malleus': [
                "Warp Disturbances Across the Sector",
                "Daemonic Incursions: Prevention Protocols",
                "Chaos Cult Activity Requires Immediate Action",
                "The Thin Veil Between Worlds Weakens"
            ]
        }
        
        return random.choice(topics.get(self.personality.ordo, topics['Hereticus']))

class InquisitorNetworkManager:
    """Manages the entire network of Inquisitor bots"""
    
    def __init__(self):
        self.db_manager = DatabaseManager(Config.DATABASE_PATH)
        self.openai_client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)
        self.bots: Dict[str, InquisitorBot] = {}
        self.scheduler = BackgroundScheduler()
        self.running = False
        
        # Initialize personalities
        self.personalities = self._create_personalities()
        
        logger.info("InquisitorNetworkManager initialized")
    
    def _create_personalities(self) -> Dict[str, InquisitorPersonality]:
        """Create the three main Inquisitor personalities"""
        personalities = {
            'Verax': InquisitorPersonality(
                name="Inquisitor Verax",
                ordo="Hereticus",
                philosophy="puritan",
                traits=["fanatical", "uncompromising", "zealous", "suspicious"],
                speech_patterns=[
                    "By the Emperor's sacred light",
                    "Heresy must be purged",
                    "The unclean shall burn",
                    "In His name, we serve"
                ],
                encryption_key="verax_cipher_7",
                faction_relationships={
                    "Hereticus": "loyal",
                    "Xenos": "suspicious",
                    "Malleus": "respectful"
                }
            ),
            'Kaelus': InquisitorPersonality(
                name="Inquisitor Kaelus",
                ordo="Xenos",
                philosophy="radical",
                traits=["intellectual", "pragmatic", "curious", "controversial"],
                speech_patterns=[
                    "Knowledge is power",
                    "The greater good requires sacrifice",
                    "We must understand our enemies",
                    "Adaptation ensures survival"
                ],
                encryption_key="kaelus_xenotech_13",
                faction_relationships={
                    "Xenos": "loyal",
                    "Hereticus": "antagonistic",
                    "Malleus": "cooperative"
                }
            ),
            'Lysander': InquisitorPersonality(
                name="Inquisitor Lysander",
                ordo="Malleus",
                philosophy="puritan",
                traits=["stoic", "cryptic", "militant", "prophetic"],
                speech_patterns=[
                    "The warp whispers of danger",
                    "Chaos eternal, vigilance eternal",
                    "In darkness, we are the light",
                    "The Emperor's will be done"
                ],
                encryption_key="lysander_warp_9",
                faction_relationships={
                    "Malleus": "loyal",
                    "Hereticus": "cooperative",
                    "Xenos": "neutral"
                }
            )
        }
        
        return personalities
    
    def add_bot(self, bot_name: str, reddit_credentials: Dict):
        """Add a new bot to the network"""
        if bot_name not in self.personalities:
            logger.error(f"No personality defined for bot: {bot_name}")
            return
        
        personality = self.personalities[bot_name]
        bot = InquisitorBot(personality, reddit_credentials, self.openai_client, self.db_manager)
        self.bots[bot_name] = bot
        
        logger.info(f"Added bot: {bot_name}")
    
    def start_network(self):
        """Start the bot network with scheduled activities"""
        if self.running:
            logger.warning("Network already running")
            return
        
        self.running = True
        
        # Schedule random bot activities
        self.scheduler.add_job(
            self._random_bot_activity,
            'interval',
            minutes=random.randint(30, 90),
            id='random_activity'
        )
        
        # Schedule daily maintenance
        self.scheduler.add_job(
            self._daily_maintenance,
            'cron',
            hour=0,
            minute=0,
            id='daily_maintenance'
        )
        
        self.scheduler.start()
        logger.info("InquisitorNet network started")
    
    def stop_network(self):
        """Stop the bot network"""
        if not self.running:
            return
        
        self.running = False
        self.scheduler.shutdown()
        logger.info("InquisitorNet network stopped")
    
    def _random_bot_activity(self):
        """Trigger random bot activity"""
        if not self.bots:
            return
        
        available_bots = [bot for bot in self.bots.values() if bot.can_post()]
        if not available_bots:
            logger.info("No bots available for posting")
            return
        
        # Select random bot
        bot = random.choice(available_bots)
        
        # Get recent posts to potentially reply to
        recent_posts = self._get_recent_posts(Config.SUBREDDIT_NAME, limit=5)
        
        if recent_posts and random.choice([True, False]):
            # Reply to existing post
            post_id = random.choice(recent_posts)
            bot.reply_to_post(post_id, Config.SUBREDDIT_NAME)
        else:
            # Create new post
            bot.create_post(Config.SUBREDDIT_NAME)
    
    def _get_recent_posts(self, subreddit_name: str, limit: int = 10) -> List[str]:
        """Get recent post IDs from subreddit"""
        try:
            if not self.bots:
                return []
            
            # Use first bot's reddit connection
            bot = list(self.bots.values())[0]
            subreddit = bot.reddit.subreddit(subreddit_name)
            
            post_ids = []
            for submission in subreddit.new(limit=limit):
                post_ids.append(submission.id)
            
            return post_ids
            
        except Exception as e:
            logger.error(f"Error getting recent posts: {e}")
            return []
    
    def _daily_maintenance(self):
        """Perform daily maintenance tasks"""
        logger.info("Running daily maintenance")
        
        # Clean up old memories (keep last 100 per bot)
        # This would be implemented based on your needs
        
        # Generate status report
        total_posts = len(self.bots) * Config.MAX_DAILY_POSTS
        logger.info(f"Daily maintenance complete. Max posts per day: {total_posts}")

def main():
    """Main function to run the InquisitorNet"""
    
    # Check required environment variables
    required_vars = ['REDDIT_CLIENT_ID', 'REDDIT_CLIENT_SECRET', 'OPENAI_API_KEY']
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        logger.error(f"Missing required environment variables: {missing_vars}")
        return
    
    # Initialize network manager
    network = InquisitorNetworkManager()
    
    # Add bots (you'll need to provide actual Reddit credentials)
    bot_credentials = {
        'Verax': {
            'client_id': Config.REDDIT_CLIENT_ID,
            'client_secret': Config.REDDIT_CLIENT_SECRET,
            'username': os.getenv('REDDIT_USERNAME_VERAX'),
            'password': os.getenv('REDDIT_PASSWORD_VERAX')
        },
        'Kaelus': {
            'client_id': Config.REDDIT_CLIENT_ID,
            'client_secret': Config.REDDIT_CLIENT_SECRET,
            'username': os.getenv('REDDIT_USERNAME_KAELUS'),
            'password': os.getenv('REDDIT_PASSWORD_KAELUS')
        },
        'Lysander': {
            'client_id': Config.REDDIT_CLIENT_ID,
            'client_secret': Config.REDDIT_CLIENT_SECRET,
            'username': os.getenv('REDDIT_USERNAME_LYSANDER'),
            'password': os.getenv('REDDIT_PASSWORD_LYSANDER')
        }
    }
    
    # Add each bot to the network
    for bot_name, credentials in bot_credentials.items():
        if all(credentials.values()):  # Only add if all credentials are provided
            network.add_bot(bot_name, credentials)
        else:
            logger.warning(f"Missing credentials for bot: {bot_name}")
    
    if not network.bots:
        logger.error("No bots could be initialized. Check your credentials.")
        return
    
    try:
        # Start the network
        network.start_network()
        logger.info("InquisitorNet is now running...")
        
        # Keep the program running
        while True:
            time.sleep(60)  # Sleep for 1 minute
            
    except KeyboardInterrupt:
        logger.info("Shutting down InquisitorNet...")
        network.stop_network()
        logger.info("InquisitorNet stopped.")

if __name__ == "__main__":
    # main()
    pass


# Additional utility functions and classes

class HeresyScanner:
    """Phase 2 functionality - Scans for heretical content in target subreddits"""
    
    def __init__(self, reddit_client, db_manager: DatabaseManager):
        self.reddit = reddit_client
        self.db_manager = db_manager
        self.target_subreddits = [
            'Warhammer40k',
            'Grimdank',
            'AdeptusMechanicus',
            'Tau40K',
            'Eldar',
            'Chaos40k'
        ]
        self.heresy_keywords = {
            'xenos_sympathy': [
                'tau are good', 'eldar are right', 'tyranids are cool',
                'chaos is better', 'imperium is wrong', 'emperor is false'
            ],
            'heretical_doctrine': [
                'chaos gods are powerful', 'warp travel is safe',
                'mutation is good', 'psykers are safe', 'aliens are friends'
            ],
            'blasphemy': [
                'emperor is dead', 'golden throne is fake',
                'imperial creed is wrong', 'space marines are overrated'
            ]
        }
    
    def scan_subreddit(self, subreddit_name: str, limit: int = 10) -> List[Dict]:
        """Scan a subreddit for heretical content"""
        heretical_posts = []
        
        try:
            subreddit = self.reddit.subreddit(subreddit_name)
            
            for submission in subreddit.new(limit=limit):
                heresy_score = self._calculate_heresy_score(submission.title + " " + submission.selftext)
                
                if heresy_score > 0:
                    heretical_posts.append({
                        'post_id': submission.id,
                        'title': submission.title,
                        'author': str(submission.author),
                        'content': submission.selftext,
                        'heresy_score': heresy_score,
                        'heresy_type': self._classify_heresy(submission.title + " " + submission.selftext),
                        'url': submission.url,
                        'subreddit': subreddit_name
                    })
            
            return heretical_posts
            
        except Exception as e:
            logger.error(f"Error scanning subreddit {subreddit_name}: {e}")
            return []
    
    def _calculate_heresy_score(self, text: str) -> int:
        """Calculate how heretical a piece of text is"""
        text_lower = text.lower()
        score = 0
        
        for category, keywords in self.heresy_keywords.items():
            for keyword in keywords:
                if keyword in text_lower:
                    score += 1
        
        return score
    
    def _classify_heresy(self, text: str) -> str:
        """Classify the type of heresy detected"""
        text_lower = text.lower()
        
        for category, keywords in self.heresy_keywords.items():
            for keyword in keywords:
                if keyword in text_lower:
                    return category
        
        return 'general_heresy'

class InquisitorResponseTemplates:
    """Templates for generating more authentic Inquisitor responses"""
    
    OPENING_PHRASES = {
        'puritan': [
            "By the Emperor's sacred light,",
            "In the name of the Golden Throne,",
            "The Emperor protects, and we are His instruments.",
            "Heresy must be purged wherever it festers."
        ],
        'radical': [
            "Knowledge is power, guard it well.",
            "The greater good requires difficult choices.",
            "We must understand our enemies to defeat them.",
            "Pragmatism serves the Emperor's will."
        ]
    }
    
    CLOSING_PHRASES = {
        'puritan': [
            "The Emperor's will be done.",
            "In His name, we serve.",
            "Purge the unclean.",
            "For the glory of the Imperium."
        ],
        'radical': [
            "Adapt or perish.",
            "Evolution serves survival.",
            "The ends justify the means.",
            "In darkness, we find light."
        ]
    }
    
    INVESTIGATION_PHRASES = [
        "I shall investigate this matter thoroughly.",
        "This warrants further scrutiny.",
        "The evidence must be examined.",
        "We shall uncover the truth."
    ]
    
    ACCUSATION_PHRASES = [
        "This reeks of heresy.",
        "The taint of corruption is evident.",
        "Suspicion falls upon...",
        "The guilty shall be brought to justice."
    ]